we engage in productivitymaxxing

- forge is used for dev.
- everything is run off a mainnet fork - tests. we test in prod - literally. but without the gas cost.
- contract tests written in solidity (see Swapper.sol). `forge test -vvv` gives you lovely stack traces.
- all contracts are deployed using niacin. this gives us:
  - no-config upgradeable contracts
  - no-config dependency injection - used to split contracts to manage size limits.
  - no-config library linking - allows us to link the circom verifier contracts without any additional config.
  - automatic deployment tracking - keeps tracks of names, abi's, addresses.
  - autogenerated NPM packages for accessing these deployments
- the e2e integration test is a great example of levering multiple tools for productivity:
  - we deploy in one command using niacin
  - access these deployed addresses by importing one js file, autogenerated by niacin
  - typechain is used to generate typescript bindings for our contracts
- this gives us tremendous productivity gains.

importantly:
- each abstraction is only as large as it needs to be. this is a very important concept for containing complexity, which
  only arises later down the line.

  take for example the niacin index.js.
  this file is not an NPM package - which would introduce additional complexity re: imports, locally linking it. 
  instead it's just one-line import.

  what if we want to run an e2e test that utilises multiple chains? it is straightforward using our setup:
  1. setup two fork nodes using `anvil`, pointing at each chain
  2. deploy using niacin twice to each chain, generating two deployment manifests.
  3. generate the index.js for both chains using niacin.
  4. inside our test, connect to both chains. and voila.

  if you visualise it, it composes very well:

  (
    deploy-multichain (optimism arbitrum)
  )
  >>>
  (
    (deploy optimism)
    (deploy arbitrum)
  )
  >>>
  (
    (
      (anvil (fork optimism))
      ((niacin deploy) optimism)
      ((niacin generate-indexjs) optimism)
      ((typechain generate) optimism)
    )
    (
      (anvil (fork arbitrum))
      ((niacin deploy) arbitrum)
      ((niacin generate-indexjs) arbitrum)
      ((typechain generate) arbitrum)
    )
  )

  This is the power of good abstractions.

the thing which people don't understand about abstractions, is that they apply in all domains
not just code
abstractions hide complexity (ideally, although for software this is not true)
some non-technical abstractions we use:

 - code organisation
   - circuits are split into circuits/lib/ and circuits/verifiers/
     verifiers are circuits which are the "main" entrypoints. those that are compiled to be on-chain verifiers.
     you will see in contracts/verifiers where these verifiers are located.
 - test organisation
   - tests ideally test one aspect of the functionality well. solidity mandates internal and public functions,
     which have different tradeoffs in practice.

     as such, for tests you develop "harnesses", which inherit from the base contract and "expose" the
     internal functions for testing.

     these are located in src/test/harness/
     harnesses are named Test$Contract. For example, TestSwapper inherits the Swapper contract and exposes
     some functions.

     each test inherits from the test contract in order to utilise it. we split the tests from harnesses in
     order to emphasise that a harness is an abstraction which does just one thing - exposes functions for testing.
  - $TEMPEST_TREE_LEVELS_GLOBAL
    this is an interesting case of solving a problem that isn't covered by any existing tool
    while it might not be very important, it is useful.
    the merkle tree depth is fixed. three different areas of code share this item of configuration - circom, solidity and typescript
    there is no way to share the value eg. with a JSON file, since circom/sol don't support that
    inserting a simple placeholder comment is enough to locate this value across all three codebases.



of course, 